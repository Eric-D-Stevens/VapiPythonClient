# coding: utf-8

"""
    Vapi API

    API for building voice assistants  # noqa: E501

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class Assistant(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'transcriber': 'OneOfAssistantTranscriber',
        'model': 'OneOfAssistantModel',
        'voice': 'OneOfAssistantVoice',
        'first_message_mode': 'str',
        'recording_enabled': 'bool',
        'hipaa_enabled': 'bool',
        'client_messages': 'list[str]',
        'server_messages': 'list[str]',
        'silence_timeout_seconds': 'float',
        'response_delay_seconds': 'float',
        'llm_request_delay_seconds': 'float',
        'llm_request_non_punctuated_delay_seconds': 'float',
        'num_words_to_interrupt_assistant': 'float',
        'max_duration_seconds': 'float',
        'background_sound': 'str',
        'backchanneling_enabled': 'bool',
        'background_denoising_enabled': 'bool',
        'model_output_in_messages_enabled': 'bool',
        'transport_configurations': 'list[OneOfAssistantTransportConfigurationsItems]',
        'is_server_url_secret_set': 'object',
        'name': 'str',
        'first_message': 'str',
        'voicemail_detection': 'AllOfAssistantVoicemailDetection',
        'voicemail_message': 'str',
        'end_call_message': 'str',
        'end_call_phrases': 'list[str]',
        'metadata': 'object',
        'server_url': 'str',
        'server_url_secret': 'str',
        'analysis_plan': 'AllOfAssistantAnalysisPlan',
        'artifact_plan': 'AllOfAssistantArtifactPlan',
        'message_plan': 'AllOfAssistantMessagePlan',
        'credential_ids': 'list[str]',
        'id': 'str',
        'org_id': 'str',
        'created_at': 'datetime',
        'updated_at': 'datetime'
    }

    attribute_map = {
        'transcriber': 'transcriber',
        'model': 'model',
        'voice': 'voice',
        'first_message_mode': 'firstMessageMode',
        'recording_enabled': 'recordingEnabled',
        'hipaa_enabled': 'hipaaEnabled',
        'client_messages': 'clientMessages',
        'server_messages': 'serverMessages',
        'silence_timeout_seconds': 'silenceTimeoutSeconds',
        'response_delay_seconds': 'responseDelaySeconds',
        'llm_request_delay_seconds': 'llmRequestDelaySeconds',
        'llm_request_non_punctuated_delay_seconds': 'llmRequestNonPunctuatedDelaySeconds',
        'num_words_to_interrupt_assistant': 'numWordsToInterruptAssistant',
        'max_duration_seconds': 'maxDurationSeconds',
        'background_sound': 'backgroundSound',
        'backchanneling_enabled': 'backchannelingEnabled',
        'background_denoising_enabled': 'backgroundDenoisingEnabled',
        'model_output_in_messages_enabled': 'modelOutputInMessagesEnabled',
        'transport_configurations': 'transportConfigurations',
        'is_server_url_secret_set': 'isServerUrlSecretSet',
        'name': 'name',
        'first_message': 'firstMessage',
        'voicemail_detection': 'voicemailDetection',
        'voicemail_message': 'voicemailMessage',
        'end_call_message': 'endCallMessage',
        'end_call_phrases': 'endCallPhrases',
        'metadata': 'metadata',
        'server_url': 'serverUrl',
        'server_url_secret': 'serverUrlSecret',
        'analysis_plan': 'analysisPlan',
        'artifact_plan': 'artifactPlan',
        'message_plan': 'messagePlan',
        'credential_ids': 'credentialIds',
        'id': 'id',
        'org_id': 'orgId',
        'created_at': 'createdAt',
        'updated_at': 'updatedAt'
    }

    def __init__(self, transcriber=None, model=None, voice=None, first_message_mode=None, recording_enabled=None, hipaa_enabled=None, client_messages=None, server_messages=None, silence_timeout_seconds=None, response_delay_seconds=None, llm_request_delay_seconds=None, llm_request_non_punctuated_delay_seconds=None, num_words_to_interrupt_assistant=None, max_duration_seconds=None, background_sound=None, backchanneling_enabled=None, background_denoising_enabled=None, model_output_in_messages_enabled=None, transport_configurations=None, is_server_url_secret_set=None, name=None, first_message=None, voicemail_detection=None, voicemail_message=None, end_call_message=None, end_call_phrases=None, metadata=None, server_url=None, server_url_secret=None, analysis_plan=None, artifact_plan=None, message_plan=None, credential_ids=None, id=None, org_id=None, created_at=None, updated_at=None):  # noqa: E501
        """Assistant - a model defined in Swagger"""  # noqa: E501
        self._transcriber = None
        self._model = None
        self._voice = None
        self._first_message_mode = None
        self._recording_enabled = None
        self._hipaa_enabled = None
        self._client_messages = None
        self._server_messages = None
        self._silence_timeout_seconds = None
        self._response_delay_seconds = None
        self._llm_request_delay_seconds = None
        self._llm_request_non_punctuated_delay_seconds = None
        self._num_words_to_interrupt_assistant = None
        self._max_duration_seconds = None
        self._background_sound = None
        self._backchanneling_enabled = None
        self._background_denoising_enabled = None
        self._model_output_in_messages_enabled = None
        self._transport_configurations = None
        self._is_server_url_secret_set = None
        self._name = None
        self._first_message = None
        self._voicemail_detection = None
        self._voicemail_message = None
        self._end_call_message = None
        self._end_call_phrases = None
        self._metadata = None
        self._server_url = None
        self._server_url_secret = None
        self._analysis_plan = None
        self._artifact_plan = None
        self._message_plan = None
        self._credential_ids = None
        self._id = None
        self._org_id = None
        self._created_at = None
        self._updated_at = None
        self.discriminator = None
        if transcriber is not None:
            self.transcriber = transcriber
        if model is not None:
            self.model = model
        if voice is not None:
            self.voice = voice
        if first_message_mode is not None:
            self.first_message_mode = first_message_mode
        if recording_enabled is not None:
            self.recording_enabled = recording_enabled
        if hipaa_enabled is not None:
            self.hipaa_enabled = hipaa_enabled
        if client_messages is not None:
            self.client_messages = client_messages
        if server_messages is not None:
            self.server_messages = server_messages
        if silence_timeout_seconds is not None:
            self.silence_timeout_seconds = silence_timeout_seconds
        if response_delay_seconds is not None:
            self.response_delay_seconds = response_delay_seconds
        if llm_request_delay_seconds is not None:
            self.llm_request_delay_seconds = llm_request_delay_seconds
        if llm_request_non_punctuated_delay_seconds is not None:
            self.llm_request_non_punctuated_delay_seconds = llm_request_non_punctuated_delay_seconds
        if num_words_to_interrupt_assistant is not None:
            self.num_words_to_interrupt_assistant = num_words_to_interrupt_assistant
        if max_duration_seconds is not None:
            self.max_duration_seconds = max_duration_seconds
        if background_sound is not None:
            self.background_sound = background_sound
        if backchanneling_enabled is not None:
            self.backchanneling_enabled = backchanneling_enabled
        if background_denoising_enabled is not None:
            self.background_denoising_enabled = background_denoising_enabled
        if model_output_in_messages_enabled is not None:
            self.model_output_in_messages_enabled = model_output_in_messages_enabled
        if transport_configurations is not None:
            self.transport_configurations = transport_configurations
        self.is_server_url_secret_set = is_server_url_secret_set
        if name is not None:
            self.name = name
        if first_message is not None:
            self.first_message = first_message
        if voicemail_detection is not None:
            self.voicemail_detection = voicemail_detection
        if voicemail_message is not None:
            self.voicemail_message = voicemail_message
        if end_call_message is not None:
            self.end_call_message = end_call_message
        if end_call_phrases is not None:
            self.end_call_phrases = end_call_phrases
        if metadata is not None:
            self.metadata = metadata
        if server_url is not None:
            self.server_url = server_url
        if server_url_secret is not None:
            self.server_url_secret = server_url_secret
        if analysis_plan is not None:
            self.analysis_plan = analysis_plan
        if artifact_plan is not None:
            self.artifact_plan = artifact_plan
        if message_plan is not None:
            self.message_plan = message_plan
        if credential_ids is not None:
            self.credential_ids = credential_ids
        self.id = id
        self.org_id = org_id
        self.created_at = created_at
        self.updated_at = updated_at

    @property
    def transcriber(self):
        """Gets the transcriber of this Assistant.  # noqa: E501

        These are the options for the assistant's transcriber.  # noqa: E501

        :return: The transcriber of this Assistant.  # noqa: E501
        :rtype: OneOfAssistantTranscriber
        """
        return self._transcriber

    @transcriber.setter
    def transcriber(self, transcriber):
        """Sets the transcriber of this Assistant.

        These are the options for the assistant's transcriber.  # noqa: E501

        :param transcriber: The transcriber of this Assistant.  # noqa: E501
        :type: OneOfAssistantTranscriber
        """

        self._transcriber = transcriber

    @property
    def model(self):
        """Gets the model of this Assistant.  # noqa: E501

        These are the options for the assistant's LLM.  # noqa: E501

        :return: The model of this Assistant.  # noqa: E501
        :rtype: OneOfAssistantModel
        """
        return self._model

    @model.setter
    def model(self, model):
        """Sets the model of this Assistant.

        These are the options for the assistant's LLM.  # noqa: E501

        :param model: The model of this Assistant.  # noqa: E501
        :type: OneOfAssistantModel
        """

        self._model = model

    @property
    def voice(self):
        """Gets the voice of this Assistant.  # noqa: E501

        These are the options for the assistant's voice.  # noqa: E501

        :return: The voice of this Assistant.  # noqa: E501
        :rtype: OneOfAssistantVoice
        """
        return self._voice

    @voice.setter
    def voice(self, voice):
        """Sets the voice of this Assistant.

        These are the options for the assistant's voice.  # noqa: E501

        :param voice: The voice of this Assistant.  # noqa: E501
        :type: OneOfAssistantVoice
        """

        self._voice = voice

    @property
    def first_message_mode(self):
        """Gets the first_message_mode of this Assistant.  # noqa: E501

        This is the mode for the first message. Default is 'assistant-speaks-first'.  Use: - 'assistant-speaks-first' to have the assistant speak first. - 'assistant-waits-for-user' to have the assistant wait for the user to speak first. - 'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (`assistant.model.messages` at call start, `call.messages` at squad transfer points).  @default 'assistant-speaks-first'  # noqa: E501

        :return: The first_message_mode of this Assistant.  # noqa: E501
        :rtype: str
        """
        return self._first_message_mode

    @first_message_mode.setter
    def first_message_mode(self, first_message_mode):
        """Sets the first_message_mode of this Assistant.

        This is the mode for the first message. Default is 'assistant-speaks-first'.  Use: - 'assistant-speaks-first' to have the assistant speak first. - 'assistant-waits-for-user' to have the assistant wait for the user to speak first. - 'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (`assistant.model.messages` at call start, `call.messages` at squad transfer points).  @default 'assistant-speaks-first'  # noqa: E501

        :param first_message_mode: The first_message_mode of this Assistant.  # noqa: E501
        :type: str
        """
        allowed_values = ["assistant-speaks-first", "assistant-speaks-first-with-model-generated-message", "assistant-waits-for-user"]  # noqa: E501
        if first_message_mode not in allowed_values:
            raise ValueError(
                "Invalid value for `first_message_mode` ({0}), must be one of {1}"  # noqa: E501
                .format(first_message_mode, allowed_values)
            )

        self._first_message_mode = first_message_mode

    @property
    def recording_enabled(self):
        """Gets the recording_enabled of this Assistant.  # noqa: E501

        This sets whether the assistant's calls are recorded. Defaults to true.  # noqa: E501

        :return: The recording_enabled of this Assistant.  # noqa: E501
        :rtype: bool
        """
        return self._recording_enabled

    @recording_enabled.setter
    def recording_enabled(self, recording_enabled):
        """Sets the recording_enabled of this Assistant.

        This sets whether the assistant's calls are recorded. Defaults to true.  # noqa: E501

        :param recording_enabled: The recording_enabled of this Assistant.  # noqa: E501
        :type: bool
        """

        self._recording_enabled = recording_enabled

    @property
    def hipaa_enabled(self):
        """Gets the hipaa_enabled of this Assistant.  # noqa: E501

        When this is enabled, no logs, recordings, or transcriptions will be stored. At the end of the call, you will still receive an end-of-call-report message to store on your server. Defaults to false.  # noqa: E501

        :return: The hipaa_enabled of this Assistant.  # noqa: E501
        :rtype: bool
        """
        return self._hipaa_enabled

    @hipaa_enabled.setter
    def hipaa_enabled(self, hipaa_enabled):
        """Sets the hipaa_enabled of this Assistant.

        When this is enabled, no logs, recordings, or transcriptions will be stored. At the end of the call, you will still receive an end-of-call-report message to store on your server. Defaults to false.  # noqa: E501

        :param hipaa_enabled: The hipaa_enabled of this Assistant.  # noqa: E501
        :type: bool
        """

        self._hipaa_enabled = hipaa_enabled

    @property
    def client_messages(self):
        """Gets the client_messages of this Assistant.  # noqa: E501

        These are the messages that will be sent to your Client SDKs. Default is conversation-update,function-call,hang,model-output,speech-update,status-update,transcript,tool-calls,user-interrupted,voice-input. You can check the shape of the messages in ClientMessage schema.  # noqa: E501

        :return: The client_messages of this Assistant.  # noqa: E501
        :rtype: list[str]
        """
        return self._client_messages

    @client_messages.setter
    def client_messages(self, client_messages):
        """Sets the client_messages of this Assistant.

        These are the messages that will be sent to your Client SDKs. Default is conversation-update,function-call,hang,model-output,speech-update,status-update,transcript,tool-calls,user-interrupted,voice-input. You can check the shape of the messages in ClientMessage schema.  # noqa: E501

        :param client_messages: The client_messages of this Assistant.  # noqa: E501
        :type: list[str]
        """
        allowed_values = ["conversation-update", "function-call", "function-call-result", "hang", "metadata", "model-output", "speech-update", "status-update", "transcript", "tool-calls", "tool-calls-result", "user-interrupted", "voice-input"]  # noqa: E501
        if not set(client_messages).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `client_messages` [{0}], must be a subset of [{1}]"  # noqa: E501
                .format(", ".join(map(str, set(client_messages) - set(allowed_values))),  # noqa: E501
                        ", ".join(map(str, allowed_values)))
            )

        self._client_messages = client_messages

    @property
    def server_messages(self):
        """Gets the server_messages of this Assistant.  # noqa: E501

        These are the messages that will be sent to your Server URL. Default is conversation-update,end-of-call-report,function-call,hang,speech-update,status-update,tool-calls,transfer-destination-request,user-interrupted. You can check the shape of the messages in ServerMessage schema.  # noqa: E501

        :return: The server_messages of this Assistant.  # noqa: E501
        :rtype: list[str]
        """
        return self._server_messages

    @server_messages.setter
    def server_messages(self, server_messages):
        """Sets the server_messages of this Assistant.

        These are the messages that will be sent to your Server URL. Default is conversation-update,end-of-call-report,function-call,hang,speech-update,status-update,tool-calls,transfer-destination-request,user-interrupted. You can check the shape of the messages in ServerMessage schema.  # noqa: E501

        :param server_messages: The server_messages of this Assistant.  # noqa: E501
        :type: list[str]
        """
        allowed_values = ["conversation-update", "end-of-call-report", "function-call", "hang", "model-output", "phone-call-control", "speech-update", "status-update", "transcript", "tool-calls", "transfer-destination-request", "transfer-update", "user-interrupted", "voice-input"]  # noqa: E501
        if not set(server_messages).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `server_messages` [{0}], must be a subset of [{1}]"  # noqa: E501
                .format(", ".join(map(str, set(server_messages) - set(allowed_values))),  # noqa: E501
                        ", ".join(map(str, allowed_values)))
            )

        self._server_messages = server_messages

    @property
    def silence_timeout_seconds(self):
        """Gets the silence_timeout_seconds of this Assistant.  # noqa: E501

        How many seconds of silence to wait before ending the call. Defaults to 30.  @default 30  # noqa: E501

        :return: The silence_timeout_seconds of this Assistant.  # noqa: E501
        :rtype: float
        """
        return self._silence_timeout_seconds

    @silence_timeout_seconds.setter
    def silence_timeout_seconds(self, silence_timeout_seconds):
        """Sets the silence_timeout_seconds of this Assistant.

        How many seconds of silence to wait before ending the call. Defaults to 30.  @default 30  # noqa: E501

        :param silence_timeout_seconds: The silence_timeout_seconds of this Assistant.  # noqa: E501
        :type: float
        """

        self._silence_timeout_seconds = silence_timeout_seconds

    @property
    def response_delay_seconds(self):
        """Gets the response_delay_seconds of this Assistant.  # noqa: E501

        The minimum number of seconds after user speech to wait before the assistant starts speaking. Defaults to 0.4.  @default 0.4  # noqa: E501

        :return: The response_delay_seconds of this Assistant.  # noqa: E501
        :rtype: float
        """
        return self._response_delay_seconds

    @response_delay_seconds.setter
    def response_delay_seconds(self, response_delay_seconds):
        """Sets the response_delay_seconds of this Assistant.

        The minimum number of seconds after user speech to wait before the assistant starts speaking. Defaults to 0.4.  @default 0.4  # noqa: E501

        :param response_delay_seconds: The response_delay_seconds of this Assistant.  # noqa: E501
        :type: float
        """

        self._response_delay_seconds = response_delay_seconds

    @property
    def llm_request_delay_seconds(self):
        """Gets the llm_request_delay_seconds of this Assistant.  # noqa: E501

        The minimum number of seconds to wait after transcription (with punctuation) before sending a request to the model. Defaults to 0.1.  @default 0.1  # noqa: E501

        :return: The llm_request_delay_seconds of this Assistant.  # noqa: E501
        :rtype: float
        """
        return self._llm_request_delay_seconds

    @llm_request_delay_seconds.setter
    def llm_request_delay_seconds(self, llm_request_delay_seconds):
        """Sets the llm_request_delay_seconds of this Assistant.

        The minimum number of seconds to wait after transcription (with punctuation) before sending a request to the model. Defaults to 0.1.  @default 0.1  # noqa: E501

        :param llm_request_delay_seconds: The llm_request_delay_seconds of this Assistant.  # noqa: E501
        :type: float
        """

        self._llm_request_delay_seconds = llm_request_delay_seconds

    @property
    def llm_request_non_punctuated_delay_seconds(self):
        """Gets the llm_request_non_punctuated_delay_seconds of this Assistant.  # noqa: E501

        The minimum number of seconds to wait after transcription (without punctuation) before sending a request to the model. Defaults to 1.5.  @default 1.5  # noqa: E501

        :return: The llm_request_non_punctuated_delay_seconds of this Assistant.  # noqa: E501
        :rtype: float
        """
        return self._llm_request_non_punctuated_delay_seconds

    @llm_request_non_punctuated_delay_seconds.setter
    def llm_request_non_punctuated_delay_seconds(self, llm_request_non_punctuated_delay_seconds):
        """Sets the llm_request_non_punctuated_delay_seconds of this Assistant.

        The minimum number of seconds to wait after transcription (without punctuation) before sending a request to the model. Defaults to 1.5.  @default 1.5  # noqa: E501

        :param llm_request_non_punctuated_delay_seconds: The llm_request_non_punctuated_delay_seconds of this Assistant.  # noqa: E501
        :type: float
        """

        self._llm_request_non_punctuated_delay_seconds = llm_request_non_punctuated_delay_seconds

    @property
    def num_words_to_interrupt_assistant(self):
        """Gets the num_words_to_interrupt_assistant of this Assistant.  # noqa: E501

        The number of words to wait for before interrupting the assistant.  Words like \"stop\", \"actually\", \"no\", etc. will always interrupt immediately regardless of this value.  Words like \"okay\", \"yeah\", \"right\" will never interrupt.  When set to 0, it will rely solely on the VAD (Voice Activity Detector) and will not wait for any transcription. Defaults to this (0).  @default 0  # noqa: E501

        :return: The num_words_to_interrupt_assistant of this Assistant.  # noqa: E501
        :rtype: float
        """
        return self._num_words_to_interrupt_assistant

    @num_words_to_interrupt_assistant.setter
    def num_words_to_interrupt_assistant(self, num_words_to_interrupt_assistant):
        """Sets the num_words_to_interrupt_assistant of this Assistant.

        The number of words to wait for before interrupting the assistant.  Words like \"stop\", \"actually\", \"no\", etc. will always interrupt immediately regardless of this value.  Words like \"okay\", \"yeah\", \"right\" will never interrupt.  When set to 0, it will rely solely on the VAD (Voice Activity Detector) and will not wait for any transcription. Defaults to this (0).  @default 0  # noqa: E501

        :param num_words_to_interrupt_assistant: The num_words_to_interrupt_assistant of this Assistant.  # noqa: E501
        :type: float
        """

        self._num_words_to_interrupt_assistant = num_words_to_interrupt_assistant

    @property
    def max_duration_seconds(self):
        """Gets the max_duration_seconds of this Assistant.  # noqa: E501

        This is the maximum number of seconds that the call will last. When the call reaches this duration, it will be ended.  @default 1800 (~30 minutes)  # noqa: E501

        :return: The max_duration_seconds of this Assistant.  # noqa: E501
        :rtype: float
        """
        return self._max_duration_seconds

    @max_duration_seconds.setter
    def max_duration_seconds(self, max_duration_seconds):
        """Sets the max_duration_seconds of this Assistant.

        This is the maximum number of seconds that the call will last. When the call reaches this duration, it will be ended.  @default 1800 (~30 minutes)  # noqa: E501

        :param max_duration_seconds: The max_duration_seconds of this Assistant.  # noqa: E501
        :type: float
        """

        self._max_duration_seconds = max_duration_seconds

    @property
    def background_sound(self):
        """Gets the background_sound of this Assistant.  # noqa: E501

        This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.  # noqa: E501

        :return: The background_sound of this Assistant.  # noqa: E501
        :rtype: str
        """
        return self._background_sound

    @background_sound.setter
    def background_sound(self, background_sound):
        """Sets the background_sound of this Assistant.

        This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.  # noqa: E501

        :param background_sound: The background_sound of this Assistant.  # noqa: E501
        :type: str
        """
        allowed_values = ["off", "office"]  # noqa: E501
        if background_sound not in allowed_values:
            raise ValueError(
                "Invalid value for `background_sound` ({0}), must be one of {1}"  # noqa: E501
                .format(background_sound, allowed_values)
            )

        self._background_sound = background_sound

    @property
    def backchanneling_enabled(self):
        """Gets the backchanneling_enabled of this Assistant.  # noqa: E501

        This determines whether the model says 'mhmm', 'ahem' etc. while user is speaking.  Default `false` while in beta.  @default false  # noqa: E501

        :return: The backchanneling_enabled of this Assistant.  # noqa: E501
        :rtype: bool
        """
        return self._backchanneling_enabled

    @backchanneling_enabled.setter
    def backchanneling_enabled(self, backchanneling_enabled):
        """Sets the backchanneling_enabled of this Assistant.

        This determines whether the model says 'mhmm', 'ahem' etc. while user is speaking.  Default `false` while in beta.  @default false  # noqa: E501

        :param backchanneling_enabled: The backchanneling_enabled of this Assistant.  # noqa: E501
        :type: bool
        """

        self._backchanneling_enabled = backchanneling_enabled

    @property
    def background_denoising_enabled(self):
        """Gets the background_denoising_enabled of this Assistant.  # noqa: E501

        This enables filtering of noise and background speech while the user is talking.  Default `false` while in beta.  @default false  # noqa: E501

        :return: The background_denoising_enabled of this Assistant.  # noqa: E501
        :rtype: bool
        """
        return self._background_denoising_enabled

    @background_denoising_enabled.setter
    def background_denoising_enabled(self, background_denoising_enabled):
        """Sets the background_denoising_enabled of this Assistant.

        This enables filtering of noise and background speech while the user is talking.  Default `false` while in beta.  @default false  # noqa: E501

        :param background_denoising_enabled: The background_denoising_enabled of this Assistant.  # noqa: E501
        :type: bool
        """

        self._background_denoising_enabled = background_denoising_enabled

    @property
    def model_output_in_messages_enabled(self):
        """Gets the model_output_in_messages_enabled of this Assistant.  # noqa: E501

        This determines whether the model's output is used in conversation history rather than the transcription of assistant's speech.  Default `false` while in beta.  @default false  # noqa: E501

        :return: The model_output_in_messages_enabled of this Assistant.  # noqa: E501
        :rtype: bool
        """
        return self._model_output_in_messages_enabled

    @model_output_in_messages_enabled.setter
    def model_output_in_messages_enabled(self, model_output_in_messages_enabled):
        """Sets the model_output_in_messages_enabled of this Assistant.

        This determines whether the model's output is used in conversation history rather than the transcription of assistant's speech.  Default `false` while in beta.  @default false  # noqa: E501

        :param model_output_in_messages_enabled: The model_output_in_messages_enabled of this Assistant.  # noqa: E501
        :type: bool
        """

        self._model_output_in_messages_enabled = model_output_in_messages_enabled

    @property
    def transport_configurations(self):
        """Gets the transport_configurations of this Assistant.  # noqa: E501

        These are the configurations to be passed to the transport providers of assistant's calls, like Twilio. You can store multiple configurations for different transport providers. For a call, only the configuration matching the call transport provider is used.  # noqa: E501

        :return: The transport_configurations of this Assistant.  # noqa: E501
        :rtype: list[OneOfAssistantTransportConfigurationsItems]
        """
        return self._transport_configurations

    @transport_configurations.setter
    def transport_configurations(self, transport_configurations):
        """Sets the transport_configurations of this Assistant.

        These are the configurations to be passed to the transport providers of assistant's calls, like Twilio. You can store multiple configurations for different transport providers. For a call, only the configuration matching the call transport provider is used.  # noqa: E501

        :param transport_configurations: The transport_configurations of this Assistant.  # noqa: E501
        :type: list[OneOfAssistantTransportConfigurationsItems]
        """

        self._transport_configurations = transport_configurations

    @property
    def is_server_url_secret_set(self):
        """Gets the is_server_url_secret_set of this Assistant.  # noqa: E501


        :return: The is_server_url_secret_set of this Assistant.  # noqa: E501
        :rtype: object
        """
        return self._is_server_url_secret_set

    @is_server_url_secret_set.setter
    def is_server_url_secret_set(self, is_server_url_secret_set):
        """Sets the is_server_url_secret_set of this Assistant.


        :param is_server_url_secret_set: The is_server_url_secret_set of this Assistant.  # noqa: E501
        :type: object
        """
        if is_server_url_secret_set is None:
            raise ValueError("Invalid value for `is_server_url_secret_set`, must not be `None`")  # noqa: E501

        self._is_server_url_secret_set = is_server_url_secret_set

    @property
    def name(self):
        """Gets the name of this Assistant.  # noqa: E501

        This is the name of the assistant.  This is required when you want to transfer between assistants in a call.  # noqa: E501

        :return: The name of this Assistant.  # noqa: E501
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """Sets the name of this Assistant.

        This is the name of the assistant.  This is required when you want to transfer between assistants in a call.  # noqa: E501

        :param name: The name of this Assistant.  # noqa: E501
        :type: str
        """

        self._name = name

    @property
    def first_message(self):
        """Gets the first_message of this Assistant.  # noqa: E501

        This is the first message that the assistant will say. This can also be a URL to a containerized audio file (mp3, wav, etc.).  If unspecified, assistant will wait for user to speak and use the model to respond once they speak.  # noqa: E501

        :return: The first_message of this Assistant.  # noqa: E501
        :rtype: str
        """
        return self._first_message

    @first_message.setter
    def first_message(self, first_message):
        """Sets the first_message of this Assistant.

        This is the first message that the assistant will say. This can also be a URL to a containerized audio file (mp3, wav, etc.).  If unspecified, assistant will wait for user to speak and use the model to respond once they speak.  # noqa: E501

        :param first_message: The first_message of this Assistant.  # noqa: E501
        :type: str
        """

        self._first_message = first_message

    @property
    def voicemail_detection(self):
        """Gets the voicemail_detection of this Assistant.  # noqa: E501

        These are the settings to configure or disable voicemail detection. Alternatively, voicemail detection can be configured using the model.tools=[VoicemailTool]. This uses Twilio's built-in detection while the VoicemailTool relies on the model to detect if a voicemail was reached. You can use neither of them, one of them, or both of them. By default, Twilio built-in detection is enabled while VoicemailTool is not.  # noqa: E501

        :return: The voicemail_detection of this Assistant.  # noqa: E501
        :rtype: AllOfAssistantVoicemailDetection
        """
        return self._voicemail_detection

    @voicemail_detection.setter
    def voicemail_detection(self, voicemail_detection):
        """Sets the voicemail_detection of this Assistant.

        These are the settings to configure or disable voicemail detection. Alternatively, voicemail detection can be configured using the model.tools=[VoicemailTool]. This uses Twilio's built-in detection while the VoicemailTool relies on the model to detect if a voicemail was reached. You can use neither of them, one of them, or both of them. By default, Twilio built-in detection is enabled while VoicemailTool is not.  # noqa: E501

        :param voicemail_detection: The voicemail_detection of this Assistant.  # noqa: E501
        :type: AllOfAssistantVoicemailDetection
        """

        self._voicemail_detection = voicemail_detection

    @property
    def voicemail_message(self):
        """Gets the voicemail_message of this Assistant.  # noqa: E501

        This is the message that the assistant will say if the call is forwarded to voicemail.  If unspecified, it will hang up.  # noqa: E501

        :return: The voicemail_message of this Assistant.  # noqa: E501
        :rtype: str
        """
        return self._voicemail_message

    @voicemail_message.setter
    def voicemail_message(self, voicemail_message):
        """Sets the voicemail_message of this Assistant.

        This is the message that the assistant will say if the call is forwarded to voicemail.  If unspecified, it will hang up.  # noqa: E501

        :param voicemail_message: The voicemail_message of this Assistant.  # noqa: E501
        :type: str
        """

        self._voicemail_message = voicemail_message

    @property
    def end_call_message(self):
        """Gets the end_call_message of this Assistant.  # noqa: E501

        This is the message that the assistant will say if it ends the call.  If unspecified, it will hang up without saying anything.  # noqa: E501

        :return: The end_call_message of this Assistant.  # noqa: E501
        :rtype: str
        """
        return self._end_call_message

    @end_call_message.setter
    def end_call_message(self, end_call_message):
        """Sets the end_call_message of this Assistant.

        This is the message that the assistant will say if it ends the call.  If unspecified, it will hang up without saying anything.  # noqa: E501

        :param end_call_message: The end_call_message of this Assistant.  # noqa: E501
        :type: str
        """

        self._end_call_message = end_call_message

    @property
    def end_call_phrases(self):
        """Gets the end_call_phrases of this Assistant.  # noqa: E501

        This list contains phrases that, if spoken by the assistant, will trigger the call to be hung up. Case insensitive.  # noqa: E501

        :return: The end_call_phrases of this Assistant.  # noqa: E501
        :rtype: list[str]
        """
        return self._end_call_phrases

    @end_call_phrases.setter
    def end_call_phrases(self, end_call_phrases):
        """Sets the end_call_phrases of this Assistant.

        This list contains phrases that, if spoken by the assistant, will trigger the call to be hung up. Case insensitive.  # noqa: E501

        :param end_call_phrases: The end_call_phrases of this Assistant.  # noqa: E501
        :type: list[str]
        """

        self._end_call_phrases = end_call_phrases

    @property
    def metadata(self):
        """Gets the metadata of this Assistant.  # noqa: E501

        This is for metadata you want to store on the assistant.  # noqa: E501

        :return: The metadata of this Assistant.  # noqa: E501
        :rtype: object
        """
        return self._metadata

    @metadata.setter
    def metadata(self, metadata):
        """Sets the metadata of this Assistant.

        This is for metadata you want to store on the assistant.  # noqa: E501

        :param metadata: The metadata of this Assistant.  # noqa: E501
        :type: object
        """

        self._metadata = metadata

    @property
    def server_url(self):
        """Gets the server_url of this Assistant.  # noqa: E501

        This is the URL Vapi will communicate with via HTTP GET and POST Requests. This is used for retrieving context, function calling, and end-of-call reports.  All requests will be sent with the call object among other things relevant to that message. You can find more details in the Server URL documentation.  This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: tool.server.url > assistant.serverUrl > phoneNumber.serverUrl > org.serverUrl  # noqa: E501

        :return: The server_url of this Assistant.  # noqa: E501
        :rtype: str
        """
        return self._server_url

    @server_url.setter
    def server_url(self, server_url):
        """Sets the server_url of this Assistant.

        This is the URL Vapi will communicate with via HTTP GET and POST Requests. This is used for retrieving context, function calling, and end-of-call reports.  All requests will be sent with the call object among other things relevant to that message. You can find more details in the Server URL documentation.  This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: tool.server.url > assistant.serverUrl > phoneNumber.serverUrl > org.serverUrl  # noqa: E501

        :param server_url: The server_url of this Assistant.  # noqa: E501
        :type: str
        """

        self._server_url = server_url

    @property
    def server_url_secret(self):
        """Gets the server_url_secret of this Assistant.  # noqa: E501

        This is the secret you can set that Vapi will send with every request to your server. Will be sent as a header called x-vapi-secret.  Same precedence logic as serverUrl.  # noqa: E501

        :return: The server_url_secret of this Assistant.  # noqa: E501
        :rtype: str
        """
        return self._server_url_secret

    @server_url_secret.setter
    def server_url_secret(self, server_url_secret):
        """Sets the server_url_secret of this Assistant.

        This is the secret you can set that Vapi will send with every request to your server. Will be sent as a header called x-vapi-secret.  Same precedence logic as serverUrl.  # noqa: E501

        :param server_url_secret: The server_url_secret of this Assistant.  # noqa: E501
        :type: str
        """

        self._server_url_secret = server_url_secret

    @property
    def analysis_plan(self):
        """Gets the analysis_plan of this Assistant.  # noqa: E501

        This is the plan for analysis of assistant's calls. Stored in `call.analysis`.  # noqa: E501

        :return: The analysis_plan of this Assistant.  # noqa: E501
        :rtype: AllOfAssistantAnalysisPlan
        """
        return self._analysis_plan

    @analysis_plan.setter
    def analysis_plan(self, analysis_plan):
        """Sets the analysis_plan of this Assistant.

        This is the plan for analysis of assistant's calls. Stored in `call.analysis`.  # noqa: E501

        :param analysis_plan: The analysis_plan of this Assistant.  # noqa: E501
        :type: AllOfAssistantAnalysisPlan
        """

        self._analysis_plan = analysis_plan

    @property
    def artifact_plan(self):
        """Gets the artifact_plan of this Assistant.  # noqa: E501

        This is the plan for artifacts generated during assistant's calls. Stored in `call.artifact`.  Note: `recordingEnabled` is currently at the root level. It will be moved to `artifactPlan` in the future, but will remain backwards compatible.  # noqa: E501

        :return: The artifact_plan of this Assistant.  # noqa: E501
        :rtype: AllOfAssistantArtifactPlan
        """
        return self._artifact_plan

    @artifact_plan.setter
    def artifact_plan(self, artifact_plan):
        """Sets the artifact_plan of this Assistant.

        This is the plan for artifacts generated during assistant's calls. Stored in `call.artifact`.  Note: `recordingEnabled` is currently at the root level. It will be moved to `artifactPlan` in the future, but will remain backwards compatible.  # noqa: E501

        :param artifact_plan: The artifact_plan of this Assistant.  # noqa: E501
        :type: AllOfAssistantArtifactPlan
        """

        self._artifact_plan = artifact_plan

    @property
    def message_plan(self):
        """Gets the message_plan of this Assistant.  # noqa: E501

        This is the plan for static messages that can be spoken by the assistant during the call, like `idleMessages`.  Note: `firstMessage`, `voicemailMessage`, and `endCallMessage` are currently at the root level. They will be moved to `messagePlan` in the future, but will remain backwards compatible.  # noqa: E501

        :return: The message_plan of this Assistant.  # noqa: E501
        :rtype: AllOfAssistantMessagePlan
        """
        return self._message_plan

    @message_plan.setter
    def message_plan(self, message_plan):
        """Sets the message_plan of this Assistant.

        This is the plan for static messages that can be spoken by the assistant during the call, like `idleMessages`.  Note: `firstMessage`, `voicemailMessage`, and `endCallMessage` are currently at the root level. They will be moved to `messagePlan` in the future, but will remain backwards compatible.  # noqa: E501

        :param message_plan: The message_plan of this Assistant.  # noqa: E501
        :type: AllOfAssistantMessagePlan
        """

        self._message_plan = message_plan

    @property
    def credential_ids(self):
        """Gets the credential_ids of this Assistant.  # noqa: E501

        These are the credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can provide a subset using this.  # noqa: E501

        :return: The credential_ids of this Assistant.  # noqa: E501
        :rtype: list[str]
        """
        return self._credential_ids

    @credential_ids.setter
    def credential_ids(self, credential_ids):
        """Sets the credential_ids of this Assistant.

        These are the credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can provide a subset using this.  # noqa: E501

        :param credential_ids: The credential_ids of this Assistant.  # noqa: E501
        :type: list[str]
        """

        self._credential_ids = credential_ids

    @property
    def id(self):
        """Gets the id of this Assistant.  # noqa: E501

        This is the unique identifier for the assistant.  # noqa: E501

        :return: The id of this Assistant.  # noqa: E501
        :rtype: str
        """
        return self._id

    @id.setter
    def id(self, id):
        """Sets the id of this Assistant.

        This is the unique identifier for the assistant.  # noqa: E501

        :param id: The id of this Assistant.  # noqa: E501
        :type: str
        """
        if id is None:
            raise ValueError("Invalid value for `id`, must not be `None`")  # noqa: E501

        self._id = id

    @property
    def org_id(self):
        """Gets the org_id of this Assistant.  # noqa: E501

        This is the unique identifier for the org that this assistant belongs to.  # noqa: E501

        :return: The org_id of this Assistant.  # noqa: E501
        :rtype: str
        """
        return self._org_id

    @org_id.setter
    def org_id(self, org_id):
        """Sets the org_id of this Assistant.

        This is the unique identifier for the org that this assistant belongs to.  # noqa: E501

        :param org_id: The org_id of this Assistant.  # noqa: E501
        :type: str
        """
        if org_id is None:
            raise ValueError("Invalid value for `org_id`, must not be `None`")  # noqa: E501

        self._org_id = org_id

    @property
    def created_at(self):
        """Gets the created_at of this Assistant.  # noqa: E501

        This is the ISO 8601 date-time string of when the assistant was created.  # noqa: E501

        :return: The created_at of this Assistant.  # noqa: E501
        :rtype: datetime
        """
        return self._created_at

    @created_at.setter
    def created_at(self, created_at):
        """Sets the created_at of this Assistant.

        This is the ISO 8601 date-time string of when the assistant was created.  # noqa: E501

        :param created_at: The created_at of this Assistant.  # noqa: E501
        :type: datetime
        """
        if created_at is None:
            raise ValueError("Invalid value for `created_at`, must not be `None`")  # noqa: E501

        self._created_at = created_at

    @property
    def updated_at(self):
        """Gets the updated_at of this Assistant.  # noqa: E501

        This is the ISO 8601 date-time string of when the assistant was last updated.  # noqa: E501

        :return: The updated_at of this Assistant.  # noqa: E501
        :rtype: datetime
        """
        return self._updated_at

    @updated_at.setter
    def updated_at(self, updated_at):
        """Sets the updated_at of this Assistant.

        This is the ISO 8601 date-time string of when the assistant was last updated.  # noqa: E501

        :param updated_at: The updated_at of this Assistant.  # noqa: E501
        :type: datetime
        """
        if updated_at is None:
            raise ValueError("Invalid value for `updated_at`, must not be `None`")  # noqa: E501

        self._updated_at = updated_at

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(Assistant, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, Assistant):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
